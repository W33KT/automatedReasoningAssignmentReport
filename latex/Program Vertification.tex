\documentclass[a4paper,11pt]{article}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{caption}
\geometry{margin=1in}

\begin{document}

\title{2IMF25 Assignment 2 – Problem 4: Program Verification}
\author{Liu Yan  \\ Eindhoven University of Technology}
\date{\today}
\maketitle

\section{Program Verification (Problem 4)}

\textbf{Problem statement.}\\\\
We are given the following C program:
\begin{verbatim}
uint32_t x = nondet();
int y = 1;
while (x < (int)1e9) {
  x = x + y;
  y = 2*y + 1;
}
\end{verbatim}
Tasks:
(a) find the smallest initial value of \(x_0\) such that the loop executes exactly 15 times;
(b) analyze whether overflow or underflow can occur.

\subsection*{Symbolic Encoding of Program Semantics}

To verify this program, we represent its semantics symbolically as a system of constraints.

\paragraph{State variables.}
Each loop iteration \(i\) maintains two symbolic variables \(x_i\) and \(y_i\).
\begin{align*}
x_{i+1} &= x_i + y_i,\\
y_{i+1} &= 2y_i + 1,
\end{align*}
starting from \(y_0 = 1\) and an unconstrained \(x_0\) (the nondeterministic input).

\paragraph{Loop condition.}
The loop continues as long as \(x < 10^9\).
For “exactly 15 iterations”, this condition translates to:
\[
x_{14} < 10^9, \qquad x_{15} \ge 10^9.
\]
These inequalities precisely encode the boundary between iteration 14 and 15.

\subsection*{Z3 Constraint Model Construction}

We create the following constraints in Z3:
\begin{itemize}
  \item Declare integer arrays \texttt{x[0..15]}, \texttt{y[0..15]}.
  \item Add recurrence constraints:
  \[
  \texttt{y[i+1] = 2*y[i] + 1}, \quad
  \texttt{x[i+1] = x[i] + y[i]}.
  \]
  \item Add the initial condition: \texttt{y[0] = 1}.
  \item Add the loop boundary condition:
  \[
  \texttt{x[14] < 1e9}, \quad \texttt{x[15] >= 1e9}.
  \]
  \item Use Z3's \texttt{Optimize()} object to minimize \texttt{x[0]}.
\end{itemize}

The resulting Z3 script is:

\begin{verbatim}
from z3 import *

N = 15
x = [Int(f"x{i}") for i in range(N+1)]
y = [Int(f"y{i}") for i in range(N+1)]

opt = Optimize()
opt.add(y[0] == 1)
for i in range(N):
    opt.add(y[i+1] == 2*y[i] + 1)
    opt.add(x[i+1] == x[i] + y[i])
opt.add(x[14] < 10**9, x[15] >= 10**9)
opt.minimize(x[0])
opt.check()
print(opt.model())
\end{verbatim}

\subsection*{Z3 Solving Process}

Z3 expands all 15 iterations, substitutes constraints recursively, and performs
\emph{constraint propagation} until all variables are expressed in terms of \(x_0\).
Internally, it builds a system of linear arithmetic constraints of the form:
\[
x_{14} = x_0 + 32752,\quad x_{15} = x_0 + 65519,
\]
which is the same result obtained by manual symbolic expansion.

Then the optimizer solves the inequalities:
\[
x_{14} < 10^9, \quad x_{15} \ge 10^9,
\]
and determines the minimal feasible \(x_0\) satisfying both, yielding:
\[
\boxed{x_0^{min} = 999\,934\,481.}
\]

Thus, the solver reproduces automatically what we would obtain
through algebraic reasoning, but via pure logical constraint solving.

\subsection*{Result Interpretation}

For \(x_0 = 999,934,481\):
\[
x_{14} = 999,967,233 < 10^9, \quad
x_{15} = 1,000,000,000 \ge 10^9.
\]
Therefore, the loop executes \textbf{exactly 15 iterations}.
This matches both analytical reasoning and Z3's output.




\begin{table}[h]
\centering
\begin{tabular}{r|r|r|r}
\textbf{k} & \(y_k = 2^{k+1}-1\) & \(\Delta x = y_k\) & \(x_k\) (with \(x_0=0\)) \\\hline
0 & 1 & +1 & 1 \\
1 & 3 & +3 & 4 \\
2 & 7 & +7 & 11 \\
$\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
28 & 536,870,911 & +536,870,911 & 536,870,880 \\
29 & 1,073,741,823 & +1,073,741,823 & 1,073,741,793 ($\ge 1e9$)
\end{tabular}
\caption{Growth of \(x\) and \(y\) during the loop.}
\end{table}



\subsection*{(b) Overflow Analysis}

To verify the absence of integer overflow, we modeled the program using
\textbf{Z3 BitVec (32-bit)} variables, which exactly simulate C arithmetic.
Each addition operates modulo $2^{32}$, so any overflow would automatically
wrap around to zero and can be detected by a constraint of the form
\texttt{x[i+1] < x[i]}.

\paragraph{Z3 model.}
\begin{verbatim}
x = BitVec('x', 32)
y = BitVec('y', 32)
# same recurrence as before, unrolled 15 steps
x_next = x + y
y_next = 2*y + 1
# overflow condition: x_next < x  (wrap-around)
\end{verbatim}

The solver checks whether such a model can exist. The result is \texttt{unsat},
which means no overflow occurs in 15 iterations under 32-bit semantics.

\paragraph{Interpretation.}
In unsigned arithmetic, $x$ is monotonically increasing and cannot decrease
unless a wrap-around occurs. Since the solver found no model with $x_{i+1}<x_i$,
no wrap-around is possible. For the signed variable $y$, its value stays
positive and below $2^{31}-1$ within 15 iterations, so no signed overflow
occurs either.

\paragraph{Why underflow is not modeled.}
Both variables are monotonically increasing:
$y_{k+1}=2y_k+1>y_k$ and $x_{k+1}=x_k+y_k>x_k$.
Negative or decreasing values can never occur, so underflow is semantically
impossible. Only overflow needs to be checked.

\noindent
Z3 therefore proves that the program is safe from both signed and unsigned
overflow within its execution bounds.

\subsection*{Overflow Visualization (15 iterations)}

To complement the solver-based proof, the following table shows how $x$ and $y$
grow numerically over the 15 iterations. All values remain far below the 32-bit
limits ($2^{31}-1$ for signed, $2^{32}-1$ for unsigned).

\begin{table}[h]
\centering
\begin{tabular}{r|r|r|r}
\textbf{k} & \(y_k = 2^{k+1}-1\) & \(x_k\) (with \(x_0=0\)) & Comparison to limits \\\hline
13 & 16,383 & 16,366 & $\ll 2^{31}-1$ (INT\_MAX) \\
14 & 32,767 & 32,736 & $\ll 2^{31}-1$ \\
15 & 65,535 & 65,471 & $\ll 2^{31}-1$, $\ll 2^{32}-1$
\end{tabular}
\caption{Variable magnitudes within 15 iterations (actual program case).}
\end{table}

\noindent
After 15 iterations, both $x$ and $y$ remain far below the 32-bit bounds.
Z3 confirms symbolically that no overflow or wrap-around can occur,
and the numerical visualization provides an intuitive confirmation.


\subsection*{Runtime Discussion}
\begin{itemize}
  \item (a) Integer minimization (15 steps): 0.007s in Z3.
  \item (b) BitVec 32-bit model (15 steps): 0.009s in Z3; even 29 steps remain below 0.01s.
\end{itemize}



\subsection*{Conclusions}
\begin{itemize}
\item The loop executes exactly 15 times for $x_0 = 999\,934\,481$.
\item Neither overflow nor underflow can occur.
\item Analytical and Z3 results match perfectly.
\end{itemize}

\end{document}
